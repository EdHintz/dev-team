// PR creation worker: pushes branch and creates a GitHub pull request

import { Worker, Job } from 'bullmq';
import fs from 'node:fs';
import path from 'node:path';
import { getRedisConnection } from '../utils/redis.js';
import { SPRINTS_DIR } from '../config.js';
import { pushBranch } from '../services/git-service.js';
import { createSprintPr } from '../services/github-service.js';
import { setSprintStatus } from '../services/state-service.js';
import { broadcast } from '../websocket/ws-server.js';
import { createLogger } from '../utils/logger.js';
import type { Plan, CostData } from '../../shared/types.js';

const log = createLogger('pr-worker');

interface PrJobData {
  sprintId: string;
  targetDir: string;
  baseBranch: string;
}

export function startPrWorker(): Worker {
  const connection = getRedisConnection();

  const worker = new Worker('pr-creation', async (job: Job<PrJobData>) => {
    const { sprintId, targetDir, baseBranch } = job.data;
    log.info(`Creating PR for ${sprintId}`);

    const branch = `sprint/${sprintId}`;

    // Push the branch
    await pushBranch(targetDir, branch);

    // Build PR body
    const body = buildPrBody(sprintId);

    // Create PR
    const prUrl = await createSprintPr(sprintId, branch, body, baseBranch, targetDir);

    // Save PR URL
    const prFile = path.join(SPRINTS_DIR, sprintId, '.pr-url');
    fs.writeFileSync(prFile, prUrl);

    setSprintStatus(sprintId, 'pr-created');
    broadcast({ type: 'sprint:status', sprintId, status: 'pr-created' });

    log.info(`PR created: ${prUrl}`);
    return { success: true, prUrl };
  }, {
    connection,
    concurrency: 1,
  });

  worker.on('failed', (job, err) => {
    log.error(`PR creation failed: ${err.message}`, { jobId: job?.id });
    if (job) {
      const { sprintId } = job.data as PrJobData;
      broadcast({ type: 'error', sprintId, message: `PR creation failed: ${err.message}` });
    }
  });

  log.info('PR worker started');
  return worker;
}

function buildPrBody(sprintId: string): string {
  const sprintDir = path.join(SPRINTS_DIR, sprintId);
  const parts: string[] = ['## Sprint Summary\n'];

  // Task summary
  try {
    const plan: Plan = JSON.parse(fs.readFileSync(path.join(sprintDir, 'plan.json'), 'utf-8'));
    parts.push('### Tasks\n');
    for (const task of plan.tasks) {
      parts.push(`- [x] **Task ${task.id}**: ${task.title} (${task.agent}${task.assigned_to ? `, ${task.assigned_to}` : ''})`);
    }
    parts.push('');
  } catch {
    // No plan
  }

  // Review summary
  try {
    const reviewFiles = fs.readdirSync(sprintDir).filter((f) => f.startsWith('review-'));
    if (reviewFiles.length > 0) {
      const latestReview = fs.readFileSync(path.join(sprintDir, reviewFiles[reviewFiles.length - 1]), 'utf-8');
      parts.push('### Review\n');
      parts.push(latestReview.slice(0, 500));
      parts.push('');
    }
  } catch {
    // No reviews
  }

  // Cost summary
  try {
    const costs: CostData = JSON.parse(fs.readFileSync(path.join(sprintDir, 'cost.json'), 'utf-8'));
    parts.push('### Cost\n');
    for (const [agent, seconds] of Object.entries(costs.by_agent)) {
      parts.push(`- ${agent}: ${seconds}s`);
    }
    parts.push('');
  } catch {
    // No costs
  }

  parts.push('---\nGenerated by dev-team orchestrator v2');
  return parts.join('\n');
}
